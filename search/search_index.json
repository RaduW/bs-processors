{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About This is the documentation for bs-processors, a library for processing xml/html files parsed with BeautifulSoup API The api is still 'a work in progress' and can be found at: Api documentation","title":"About"},{"location":"#about","text":"This is the documentation for bs-processors, a library for processing xml/html files parsed with BeautifulSoup","title":"About"},{"location":"#api","text":"The api is still 'a work in progress' and can be found at: Api documentation","title":"API"},{"location":"how_to/","text":"Working with bs-processors Overview bs-processors is a library for modifying/cleaning htm/xml files with minimum fuss. It is meant to be used as an alternative to something like XSLT for cases when achieving the desired result with XSLT is not possible or very difficult. The general idea is that one can combine the provided blocks and maybe write a moderate amount of custom code to create powerful document processors. The processors At the base of the library is a set of processors that can be configured to achieve typical processing steps. Processors can be assembled toghether into one combined processor in order to create the desired effect. Anybody can write a processor that can interoperate with the provided processors with relative ease. A processor is a function of the following signature: def processor ( elms : List [ Any ]) -> List [ Any ] That is a processor takes a list of elements and returns a list of elements. Typically the processor will be passed just one element, the top level document (the BeautifulSoup object). It may seem an odd choice that the processor has the above signature since it would probably be more ergonomic to take a single element as input but the choice was made in order to easyly compose a chain of processors. Since a processor may return a list of elements (and there are real world cases when this is useful) a decision was taken to also accept as parameter a list of elements making it trivial to compose processors at the expense of the slight annoyance that instead of initially passing the top level element as elm one would pass it as [elm] . The library contains a set of processor factories that take specific configurations and return processor functions. As an example, the library contains a processor factory that can generate filter processors, that is processors that selectively filter documents of certain elements. By passing a filtering function to the filter factory one gets a processor that filters the desired elements. filter_div_and_span = filter_factory ( has_name_pf ([ 'div' , 'span' ])) In the example above filter_div_and_span is a processor that will remove all elements of type div or span from the passed elms ( Note that the filtering is going to be deep, the processor will descend all the way down looking for elements to filter). For a list of all available processors check the Api. For examples of using them check the examples section. The predicates Predicates are functions that receive an argument of one of the BeautifulSoupe types ( i.e. BeautifulSoup TagElement or NavigableString ) and return a boolean value. Predicates are used by most processor factory to configure their behaviour. Writing your own predicates Although there are a lot of predicates and predicate factories that can be combined to achive most common functionality it is quite trivial to write one yourself. In this example we will create a predicate that checks if the elment is a tag or the soup element and if the element is not span. Note that you don't really need to write this particular predicate since it can be easily created by composing the existing predicates like so: my_predicate = and_pf ( is_tag_or_soup_p , not_pf ( has_name_pf ( 'span' ) ) ) The desired predicate can be written from scratch like so: def my_predicate ( elm ) -> bool : if elm is None : return False # just to be sure we don't raise if elm . name is None : return False # this is a NavigableString (a tag or a soup have name) if elm . name == 'span' return False # we don't want span elements return True # anything else is fine Of course one can combine the custom predicate with already build predicates and predicate factories like so: is_span_p = has_name_pf ( 'span' ) def my_predicate ( elm ) -> bool : if not is_tag_or_soup_p ( elm ): return False return not is_span_p ( elm ) Writing your own processors TODO","title":"Working with bs-processors"},{"location":"how_to/#working-with-bs-processors","text":"","title":"Working with bs-processors"},{"location":"how_to/#overview","text":"bs-processors is a library for modifying/cleaning htm/xml files with minimum fuss. It is meant to be used as an alternative to something like XSLT for cases when achieving the desired result with XSLT is not possible or very difficult. The general idea is that one can combine the provided blocks and maybe write a moderate amount of custom code to create powerful document processors.","title":"Overview"},{"location":"how_to/#the-processors","text":"At the base of the library is a set of processors that can be configured to achieve typical processing steps. Processors can be assembled toghether into one combined processor in order to create the desired effect. Anybody can write a processor that can interoperate with the provided processors with relative ease. A processor is a function of the following signature: def processor ( elms : List [ Any ]) -> List [ Any ] That is a processor takes a list of elements and returns a list of elements. Typically the processor will be passed just one element, the top level document (the BeautifulSoup object). It may seem an odd choice that the processor has the above signature since it would probably be more ergonomic to take a single element as input but the choice was made in order to easyly compose a chain of processors. Since a processor may return a list of elements (and there are real world cases when this is useful) a decision was taken to also accept as parameter a list of elements making it trivial to compose processors at the expense of the slight annoyance that instead of initially passing the top level element as elm one would pass it as [elm] . The library contains a set of processor factories that take specific configurations and return processor functions. As an example, the library contains a processor factory that can generate filter processors, that is processors that selectively filter documents of certain elements. By passing a filtering function to the filter factory one gets a processor that filters the desired elements. filter_div_and_span = filter_factory ( has_name_pf ([ 'div' , 'span' ])) In the example above filter_div_and_span is a processor that will remove all elements of type div or span from the passed elms ( Note that the filtering is going to be deep, the processor will descend all the way down looking for elements to filter). For a list of all available processors check the Api. For examples of using them check the examples section.","title":"The processors"},{"location":"how_to/#the-predicates","text":"Predicates are functions that receive an argument of one of the BeautifulSoupe types ( i.e. BeautifulSoup TagElement or NavigableString ) and return a boolean value. Predicates are used by most processor factory to configure their behaviour.","title":"The predicates"},{"location":"how_to/#writing-your-own-predicates","text":"Although there are a lot of predicates and predicate factories that can be combined to achive most common functionality it is quite trivial to write one yourself. In this example we will create a predicate that checks if the elment is a tag or the soup element and if the element is not span. Note that you don't really need to write this particular predicate since it can be easily created by composing the existing predicates like so: my_predicate = and_pf ( is_tag_or_soup_p , not_pf ( has_name_pf ( 'span' ) ) ) The desired predicate can be written from scratch like so: def my_predicate ( elm ) -> bool : if elm is None : return False # just to be sure we don't raise if elm . name is None : return False # this is a NavigableString (a tag or a soup have name) if elm . name == 'span' return False # we don't want span elements return True # anything else is fine Of course one can combine the custom predicate with already build predicates and predicate factories like so: is_span_p = has_name_pf ( 'span' ) def my_predicate ( elm ) -> bool : if not is_tag_or_soup_p ( elm ): return False return not is_span_p ( elm )","title":"Writing your own predicates"},{"location":"how_to/#writing-your-own-processors","text":"TODO","title":"Writing your own processors"},{"location":"examples/","text":"About All examples listed below are available in the project's examples directory. The examples can be run as they are in a virtual environment that has BeautifulSoup and bs-processors installed. The examples documentation is directly extracted from the examples code.","title":"About"},{"location":"examples/#about","text":"All examples listed below are available in the project's examples directory. The examples can be run as they are in a virtual environment that has BeautifulSoup and bs-processors installed. The examples documentation is directly extracted from the examples code.","title":"About"},{"location":"examples/unwrap_tags/","text":"How to unwrap unwanted tags Overview In this example we will use the flatten_factory processor to unwrap unwanted tags. This covers the case when we have a source file that has deeply nested structures that we would like to flatten. This type of problem can be seen when we want to clean documents that were exported as html from various text editors. In our example the useful information is buried deep inside nested <div> that have various classes. To make matters worse some information is also buried inside <font> elements. We would like to remove all superfluous <div> elements and all <font> elements while preserving the content inside them. Let's say we have the following file that we want to clean up: Input <!DOCTYPE html> < html > < body > < div > < div class = \"useless-1 bold\" > First line < font >< font > inside double font </ font ></ font > outside font. < div class = \"useless-2\" > < p > Second line </ p > </ div > </ div > < div > < p > Third line </ p > </ div > </ div > < div > Forth line < font > inside font </ font > < span > end. </ span > </ div > </ body > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a predicate that checks if an element is a <font> or if it is a ` with a marker class that designates it as not necessary. Luckily we can construct this predicate from already available building blocks. To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p , or_pf , has_class_pf should_uwrap_p = or_pf ( has_name_pf ( 'font' ), and_pf ( has_name_pf ( 'div' ), has_class_pf ([ 'useless-1' , 'useless-2' ]) ) ) After constructing the predicate all that remains is to use it to create our processor from bs_processors import unwrap_factory remove_unnecessary_wrappers = unwrap_factory ( should_uwrap_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/deeply_nested.html\" ) result = remove_unnecessary_wrappers ([ doc ]) util . save_relative_result ( result , __file__ , \"output/deeply_nested_result.html\" ) The result is: <!DOCTYPE html> < html > < body > < div > First line inside double font outside font. < p > Second line </ p > < div > < p > Third line </ p > </ div > </ div > < div > Forth line inside font < span > end. </ span > </ div > </ body > </ html >","title":"How to unwrap unwanted tags"},{"location":"examples/unwrap_tags/#how-to-unwrap-unwanted-tags","text":"","title":"How to unwrap unwanted tags"},{"location":"examples/unwrap_tags/#overview","text":"In this example we will use the flatten_factory processor to unwrap unwanted tags. This covers the case when we have a source file that has deeply nested structures that we would like to flatten. This type of problem can be seen when we want to clean documents that were exported as html from various text editors. In our example the useful information is buried deep inside nested <div> that have various classes. To make matters worse some information is also buried inside <font> elements. We would like to remove all superfluous <div> elements and all <font> elements while preserving the content inside them. Let's say we have the following file that we want to clean up:","title":"Overview"},{"location":"examples/unwrap_tags/#input","text":"<!DOCTYPE html> < html > < body > < div > < div class = \"useless-1 bold\" > First line < font >< font > inside double font </ font ></ font > outside font. < div class = \"useless-2\" > < p > Second line </ p > </ div > </ div > < div > < p > Third line </ p > </ div > </ div > < div > Forth line < font > inside font </ font > < span > end. </ span > </ div > </ body > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a predicate that checks if an element is a <font> or if it is a ` with a marker class that designates it as not necessary. Luckily we can construct this predicate from already available building blocks. To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p , or_pf , has_class_pf should_uwrap_p = or_pf ( has_name_pf ( 'font' ), and_pf ( has_name_pf ( 'div' ), has_class_pf ([ 'useless-1' , 'useless-2' ]) ) ) After constructing the predicate all that remains is to use it to create our processor from bs_processors import unwrap_factory remove_unnecessary_wrappers = unwrap_factory ( should_uwrap_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/deeply_nested.html\" ) result = remove_unnecessary_wrappers ([ doc ]) util . save_relative_result ( result , __file__ , \"output/deeply_nested_result.html\" )","title":"Input"},{"location":"examples/unwrap_tags/#the-result-is","text":"<!DOCTYPE html> < html > < body > < div > First line inside double font outside font. < p > Second line </ p > < div > < p > Third line </ p > </ div > </ div > < div > Forth line inside font < span > end. </ span > </ div > </ body > </ html >","title":"The result is:"},{"location":"examples/use_filter_proc/","text":"How to use the filter processor Overview In this example we will use the filter processor to remove unwanted tags from a sample file Let's say we have the following file that we want to clean up: Input <!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < font > </ font > < span > end. </ span ></ div > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a filter that checks if an element is a <font> element and if it is empty. Luckily we can construct this predicate from already available building blocks. The has_name_pf predicate factory can be used to check if the passed element is font and the is_empty_p can be used to check if the element is empty (contains at most white spaces). To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p is_empty_font_p = and_pf ( has_name_pf ( 'font' ), is_empty_p ) After constructing the predicate all that remains is to use it to create our filter from bs_processors import filter_factory filter_empty_font_proc = filter_factory ( is_empty_font_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/simple_filter.html\" ) result = filter_empty_font_proc ([ doc ]) util . save_relative_result ( result , __file__ , \"output/simple_filter_result.html\" ) The result is: <!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < span > end. </ span ></ div > </ html >","title":"How to use the filter processor"},{"location":"examples/use_filter_proc/#how-to-use-the-filter-processor","text":"","title":"How to use the filter processor"},{"location":"examples/use_filter_proc/#overview","text":"In this example we will use the filter processor to remove unwanted tags from a sample file Let's say we have the following file that we want to clean up:","title":"Overview"},{"location":"examples/use_filter_proc/#input","text":"<!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < font > </ font > < span > end. </ span ></ div > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a filter that checks if an element is a <font> element and if it is empty. Luckily we can construct this predicate from already available building blocks. The has_name_pf predicate factory can be used to check if the passed element is font and the is_empty_p can be used to check if the element is empty (contains at most white spaces). To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p is_empty_font_p = and_pf ( has_name_pf ( 'font' ), is_empty_p ) After constructing the predicate all that remains is to use it to create our filter from bs_processors import filter_factory filter_empty_font_proc = filter_factory ( is_empty_font_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/simple_filter.html\" ) result = filter_empty_font_proc ([ doc ]) util . save_relative_result ( result , __file__ , \"output/simple_filter_result.html\" )","title":"Input"},{"location":"examples/use_filter_proc/#the-result-is","text":"<!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < span > end. </ span ></ div > </ html >","title":"The result is:"}]}