{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About This is the documentation for bs-processors, a library for processing xml/html files parsed with BeautifulSoup API The api is still 'a work in progress' and can be found at: Api documentation","title":"About"},{"location":"#about","text":"This is the documentation for bs-processors, a library for processing xml/html files parsed with BeautifulSoup","title":"About"},{"location":"#api","text":"The api is still 'a work in progress' and can be found at: Api documentation","title":"API"},{"location":"how_to/","text":"Working with bs-processors Overview bs-processors is a library for modifying/cleaning htm/xml files with minimum fuss. It is meant to be used as an alternative to something like XSLT for cases when achieving the desired result with XSLT is not possible or very difficult. The general idea is that one can combine the provided blocks and maybe write a moderate amount of custom code to create powerful document processors. The processors At the base of the library is a set of processors that can be configured to achieve typical processing steps. Processors can be assembled toghether into one combined processor in order to create the desired effect. Anybody can write a processor that can interoperate with the provided processors with relative ease. A processor is a function of the following signature: def processor ( elms : List [ Any ]) -> List [ Any ] That is a processor takes a list of elements and returns a list of elements. Typically the processor will be passed just one element, the top level document (the BeautifulSoup object). It may seem an odd choice that the processor has the above signature since it would probably be more ergonomic to take a single element as input but the choice was made in order to easyly compose a chain of processors. Since a processor may return a list of elements (and there are real world cases when this is useful) a decision was taken to also accept as parameter a list of elements making it trivial to compose processors at the expense of the slight annoyance that instead of initially passing the top level element as elm one would pass it as [elm] . The library contains a set of processor factories that take specific configurations and return processor functions. As an example, the library contains a processor factory that can generate filter processors, that is processors that selectively filter documents of certain elements. By passing a filtering function to the filter factory one gets a processor that filters the desired elements. filter_div_and_span = filter_factory ( has_name_pf ([ 'div' , 'span' ])) In the example above filter_div_and_span is a processor that will remove all elements of type div or span from the passed elms ( Note that the filtering is going to be deep, the processor will descend all the way down looking for elements to filter). For a list of all available processors check the Api. For examples of using them check the examples section. The predicates Predicates are functions that receive an argument of one of the BeautifulSoupe types ( i.e. BeautifulSoup TagElement or NavigableString ) and return a boolean value. Predicates are used by most processor factory to configure their behaviour. Writing your own predicates Although there are a lot of predicates and predicate factories that can be combined to achive most common functionality it is quite trivial to write one yourself. In this example we will create a predicate that checks if the elment is a tag or the soup element and if the element is not span. Note that you don't really need to write this particular predicate since it can be easily created by composing the existing predicates like so: my_predicate = and_pf ( is_tag_or_soup_p , not_pf ( has_name_pf ( 'span' ) ) ) The desired predicate can be written from scratch like so: def my_predicate ( elm ) -> bool : if elm is None : return False # just to be sure we don't raise if elm . name is None : return False # this is a NavigableString (a tag or a soup have name) if elm . name == 'span' return False # we don't want span elements return True # anything else is fine Of course one can combine the custom predicate with already build predicates and predicate factories like so: is_span_p = has_name_pf ( 'span' ) def my_predicate ( elm ) -> bool : if not is_tag_or_soup_p ( elm ): return False return not is_span_p ( elm ) Writing your own processors Writing your own processors is not much more complicated than writing custom predicates. In order for a custom processor to interact with other processors the custom processor has to have the following signature: def processor ( elms : List [ Any ]) -> List [ Any ] For our example let's make a processor that adds a class attribute to all elements of type <div> from the passed elements as long as they do not have an id set. This is a rather contrived example that could be easyly implemented using the existing processors. We will only implement a simplified form that takes only one element and returns a list of elements and then we will use an already existing adaptor function to create the final processor Here's how one would write this: from bs_processors.xml_util import set_new_children , process_children from bs_processors.processor_util def add_classes_to_div_single ( elm : Any ) -> List [ Any ]: if not is_tag_or_soup_p ( elm ): return [ elm ] # nothing to proess further if elm . name == 'div' and not elm . attrs . get ( \"id\" ): clss = elm . attrs . get ( \"class\" , [ \"\" ]) if not 'my-class' in clss : clss . append ( 'my-class' ) elm . attrs . [ \"class\" ] = clss for child in elm . children : new_children = process_children ( lambda child : single_filter_proc ( should_filter , child ), elm ) set_new_children ( elm , new_children ) return [ elm ] add_classes_to_div = single_to_multiple ( add_classes_to_div_single ) Composing processors in processor chains Often we need to process documents in complex ways. Often a complex process can be broken down in a series of simple processes. As an example we may want to filter some elements, unwrap some other elements, add some attributes to other elements and finally flatten the whole result. bs-processors is designed to work with exactly this type of scenarios. All we need to do is create our processors and then chain them toghether to obtain a processor that will call all configured processors. In the example below we create a few processors and finally we chain them toghether to obtain our final processor. filter_bad_p = and_pf ( is_tag_p , has_name_pf ([ 'span' , 'div' ), has_class_pf ([ 'bad-element' ]) ) filter_bad_proc = filter_factory ( filter_bad_p ) should_unwrap_p = has_name_pf [ 'font' , 'i' , 'b' ] unwrap_proc = unwrap_factory ( should_unwrap ) is_internal_child_p = has_name_pf ([ 'span' , 'a' ]) flatten_children_p = has_name_pf ([ 'div' ]) flatten_proc = flatten_factory ( flatten_clhildren_p , is_internal_child_p ) clean_html_proc = join ([ filter_bad_proc , unwrap_proc , flatten_proc ])","title":"Working with bs-processors"},{"location":"how_to/#working-with-bs-processors","text":"","title":"Working with bs-processors"},{"location":"how_to/#overview","text":"bs-processors is a library for modifying/cleaning htm/xml files with minimum fuss. It is meant to be used as an alternative to something like XSLT for cases when achieving the desired result with XSLT is not possible or very difficult. The general idea is that one can combine the provided blocks and maybe write a moderate amount of custom code to create powerful document processors.","title":"Overview"},{"location":"how_to/#the-processors","text":"At the base of the library is a set of processors that can be configured to achieve typical processing steps. Processors can be assembled toghether into one combined processor in order to create the desired effect. Anybody can write a processor that can interoperate with the provided processors with relative ease. A processor is a function of the following signature: def processor ( elms : List [ Any ]) -> List [ Any ] That is a processor takes a list of elements and returns a list of elements. Typically the processor will be passed just one element, the top level document (the BeautifulSoup object). It may seem an odd choice that the processor has the above signature since it would probably be more ergonomic to take a single element as input but the choice was made in order to easyly compose a chain of processors. Since a processor may return a list of elements (and there are real world cases when this is useful) a decision was taken to also accept as parameter a list of elements making it trivial to compose processors at the expense of the slight annoyance that instead of initially passing the top level element as elm one would pass it as [elm] . The library contains a set of processor factories that take specific configurations and return processor functions. As an example, the library contains a processor factory that can generate filter processors, that is processors that selectively filter documents of certain elements. By passing a filtering function to the filter factory one gets a processor that filters the desired elements. filter_div_and_span = filter_factory ( has_name_pf ([ 'div' , 'span' ])) In the example above filter_div_and_span is a processor that will remove all elements of type div or span from the passed elms ( Note that the filtering is going to be deep, the processor will descend all the way down looking for elements to filter). For a list of all available processors check the Api. For examples of using them check the examples section.","title":"The processors"},{"location":"how_to/#the-predicates","text":"Predicates are functions that receive an argument of one of the BeautifulSoupe types ( i.e. BeautifulSoup TagElement or NavigableString ) and return a boolean value. Predicates are used by most processor factory to configure their behaviour.","title":"The predicates"},{"location":"how_to/#writing-your-own-predicates","text":"Although there are a lot of predicates and predicate factories that can be combined to achive most common functionality it is quite trivial to write one yourself. In this example we will create a predicate that checks if the elment is a tag or the soup element and if the element is not span. Note that you don't really need to write this particular predicate since it can be easily created by composing the existing predicates like so: my_predicate = and_pf ( is_tag_or_soup_p , not_pf ( has_name_pf ( 'span' ) ) ) The desired predicate can be written from scratch like so: def my_predicate ( elm ) -> bool : if elm is None : return False # just to be sure we don't raise if elm . name is None : return False # this is a NavigableString (a tag or a soup have name) if elm . name == 'span' return False # we don't want span elements return True # anything else is fine Of course one can combine the custom predicate with already build predicates and predicate factories like so: is_span_p = has_name_pf ( 'span' ) def my_predicate ( elm ) -> bool : if not is_tag_or_soup_p ( elm ): return False return not is_span_p ( elm )","title":"Writing your own predicates"},{"location":"how_to/#writing-your-own-processors","text":"Writing your own processors is not much more complicated than writing custom predicates. In order for a custom processor to interact with other processors the custom processor has to have the following signature: def processor ( elms : List [ Any ]) -> List [ Any ] For our example let's make a processor that adds a class attribute to all elements of type <div> from the passed elements as long as they do not have an id set. This is a rather contrived example that could be easyly implemented using the existing processors. We will only implement a simplified form that takes only one element and returns a list of elements and then we will use an already existing adaptor function to create the final processor Here's how one would write this: from bs_processors.xml_util import set_new_children , process_children from bs_processors.processor_util def add_classes_to_div_single ( elm : Any ) -> List [ Any ]: if not is_tag_or_soup_p ( elm ): return [ elm ] # nothing to proess further if elm . name == 'div' and not elm . attrs . get ( \"id\" ): clss = elm . attrs . get ( \"class\" , [ \"\" ]) if not 'my-class' in clss : clss . append ( 'my-class' ) elm . attrs . [ \"class\" ] = clss for child in elm . children : new_children = process_children ( lambda child : single_filter_proc ( should_filter , child ), elm ) set_new_children ( elm , new_children ) return [ elm ] add_classes_to_div = single_to_multiple ( add_classes_to_div_single )","title":"Writing your own processors"},{"location":"how_to/#composing-processors-in-processor-chains","text":"Often we need to process documents in complex ways. Often a complex process can be broken down in a series of simple processes. As an example we may want to filter some elements, unwrap some other elements, add some attributes to other elements and finally flatten the whole result. bs-processors is designed to work with exactly this type of scenarios. All we need to do is create our processors and then chain them toghether to obtain a processor that will call all configured processors. In the example below we create a few processors and finally we chain them toghether to obtain our final processor. filter_bad_p = and_pf ( is_tag_p , has_name_pf ([ 'span' , 'div' ), has_class_pf ([ 'bad-element' ]) ) filter_bad_proc = filter_factory ( filter_bad_p ) should_unwrap_p = has_name_pf [ 'font' , 'i' , 'b' ] unwrap_proc = unwrap_factory ( should_unwrap ) is_internal_child_p = has_name_pf ([ 'span' , 'a' ]) flatten_children_p = has_name_pf ([ 'div' ]) flatten_proc = flatten_factory ( flatten_clhildren_p , is_internal_child_p ) clean_html_proc = join ([ filter_bad_proc , unwrap_proc , flatten_proc ])","title":"Composing processors in processor chains"},{"location":"examples/","text":"About All examples listed below are available in the project's examples directory. The examples can be run as they are in a virtual environment that has BeautifulSoup and bs-processors installed. The examples documentation is directly extracted from the examples code.","title":"About"},{"location":"examples/#about","text":"All examples listed below are available in the project's examples directory. The examples can be run as they are in a virtual environment that has BeautifulSoup and bs-processors installed. The examples documentation is directly extracted from the examples code.","title":"About"},{"location":"examples/unwrap_tags/","text":"How to unwrap unwanted tags Overview In this example we will use the flatten_factory processor to unwrap unwanted tags. This covers the case when we have a source file that has deeply nested structures that we would like to flatten. This type of problem can be seen when we want to clean documents that were exported as html from various text editors. In our example the useful information is buried deep inside nested <div> that have various classes. To make matters worse some information is also buried inside <font> elements. We would like to remove all superfluous <div> elements and all <font> elements while preserving the content inside them. Let's say we have the following file that we want to clean up: Input <!DOCTYPE html> < html > < body > < div > < div class = \"useless-1 bold\" > First line < font >< font > inside double font </ font ></ font > outside font. < div class = \"useless-2\" > < p > Second line </ p > </ div > </ div > < div > < p > Third line </ p > </ div > </ div > < div > Forth line < font > inside font </ font > < span > end. </ span > </ div > </ body > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a predicate that checks if an element is a <font> or if it is a ` with a marker class that designates it as not necessary. Luckily we can construct this predicate from already available building blocks. To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , or_pf , has_class_pf should_uwrap_p = or_pf ( has_name_pf ( 'font' ), and_pf ( has_name_pf ( 'div' ), has_class_pf ([ 'useless-1' , 'useless-2' ]) ) ) After constructing the predicate all that remains is to use it to create our processor from bs_processors import unwrap_factory remove_unnecessary_wrappers = unwrap_factory ( should_uwrap_p ) Now we are ready to pass it our loaded soup and we are done import util from bs_processors.utils.file_util import process_file def main (): doc_name = util . relative_to_absolute_path_name ( __file__ , \"input/deeply_nested.html\" ) result_name = util . relative_to_absolute_path_name ( __file__ , \"output/deeply_nested_result.html\" ) process_file ( remove_unnecessary_wrappers , 'html.parser' , doc_name , result_name ) The result is: <!DOCTYPE html> < html > < body > < div > First line inside double font outside font. < p > Second line </ p > < div > < p > Third line </ p > </ div > </ div > < div > Forth line inside font < span > end. </ span > </ div > </ body > </ html >","title":"How to unwrap unwanted tags"},{"location":"examples/unwrap_tags/#how-to-unwrap-unwanted-tags","text":"","title":"How to unwrap unwanted tags"},{"location":"examples/unwrap_tags/#overview","text":"In this example we will use the flatten_factory processor to unwrap unwanted tags. This covers the case when we have a source file that has deeply nested structures that we would like to flatten. This type of problem can be seen when we want to clean documents that were exported as html from various text editors. In our example the useful information is buried deep inside nested <div> that have various classes. To make matters worse some information is also buried inside <font> elements. We would like to remove all superfluous <div> elements and all <font> elements while preserving the content inside them. Let's say we have the following file that we want to clean up:","title":"Overview"},{"location":"examples/unwrap_tags/#input","text":"<!DOCTYPE html> < html > < body > < div > < div class = \"useless-1 bold\" > First line < font >< font > inside double font </ font ></ font > outside font. < div class = \"useless-2\" > < p > Second line </ p > </ div > </ div > < div > < p > Third line </ p > </ div > </ div > < div > Forth line < font > inside font </ font > < span > end. </ span > </ div > </ body > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a predicate that checks if an element is a <font> or if it is a ` with a marker class that designates it as not necessary. Luckily we can construct this predicate from already available building blocks. To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , or_pf , has_class_pf should_uwrap_p = or_pf ( has_name_pf ( 'font' ), and_pf ( has_name_pf ( 'div' ), has_class_pf ([ 'useless-1' , 'useless-2' ]) ) ) After constructing the predicate all that remains is to use it to create our processor from bs_processors import unwrap_factory remove_unnecessary_wrappers = unwrap_factory ( should_uwrap_p ) Now we are ready to pass it our loaded soup and we are done import util from bs_processors.utils.file_util import process_file def main (): doc_name = util . relative_to_absolute_path_name ( __file__ , \"input/deeply_nested.html\" ) result_name = util . relative_to_absolute_path_name ( __file__ , \"output/deeply_nested_result.html\" ) process_file ( remove_unnecessary_wrappers , 'html.parser' , doc_name , result_name )","title":"Input"},{"location":"examples/unwrap_tags/#the-result-is","text":"<!DOCTYPE html> < html > < body > < div > First line inside double font outside font. < p > Second line </ p > < div > < p > Third line </ p > </ div > </ div > < div > Forth line inside font < span > end. </ span > </ div > </ body > </ html >","title":"The result is:"},{"location":"examples/use_filter_proc/","text":"How to use the filter processor Overview In this example we will use the filter processor to remove unwanted tags from a sample file Let's say we have the following file that we want to clean up: Input <!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < font > </ font > < span > end. </ span ></ div > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a filter that checks if an element is a <font> element and if it is empty. Luckily we can construct this predicate from already available building blocks. The has_name_pf predicate factory can be used to check if the passed element is font and the is_empty_p can be used to check if the element is empty (contains at most white spaces). To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p is_empty_font_p = and_pf ( has_name_pf ( 'font' ), is_empty_p ) After constructing the predicate all that remains is to use it to create our filter from bs_processors import filter_factory filter_empty_font_proc = filter_factory ( is_empty_font_p ) Now we are ready to pass it our loaded soup and we are done import util from bs_processors.utils.file_util import process_file def main (): doc_name = util . relative_to_absolute_path_name ( __file__ , \"input/simple_filter.html\" ) result_name = util . relative_to_absolute_path_name ( __file__ , \"output/simple_filter_result.html\" ) process_file ( filter_empty_font_proc , \"html.parser\" , doc_name , result_name ) The result is: <!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < span > end. </ span > </ div > </ html >","title":"How to use the filter processor"},{"location":"examples/use_filter_proc/#how-to-use-the-filter-processor","text":"","title":"How to use the filter processor"},{"location":"examples/use_filter_proc/#overview","text":"In this example we will use the filter processor to remove unwanted tags from a sample file Let's say we have the following file that we want to clean up:","title":"Overview"},{"location":"examples/use_filter_proc/#input","text":"<!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < font > </ font > < span > end. </ span ></ div > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a filter that checks if an element is a <font> element and if it is empty. Luckily we can construct this predicate from already available building blocks. The has_name_pf predicate factory can be used to check if the passed element is font and the is_empty_p can be used to check if the element is empty (contains at most white spaces). To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p is_empty_font_p = and_pf ( has_name_pf ( 'font' ), is_empty_p ) After constructing the predicate all that remains is to use it to create our filter from bs_processors import filter_factory filter_empty_font_proc = filter_factory ( is_empty_font_p ) Now we are ready to pass it our loaded soup and we are done import util from bs_processors.utils.file_util import process_file def main (): doc_name = util . relative_to_absolute_path_name ( __file__ , \"input/simple_filter.html\" ) result_name = util . relative_to_absolute_path_name ( __file__ , \"output/simple_filter_result.html\" ) process_file ( filter_empty_font_proc , \"html.parser\" , doc_name , result_name )","title":"Input"},{"location":"examples/use_filter_proc/#the-result-is","text":"<!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < span > end. </ span > </ div > </ html >","title":"The result is:"},{"location":"examples/use_process_directory/","text":"How to use file and directory utilities Overview In this example we will use the process_directory utility function to process a directory. In order to simplify the application of filters bs-processor contains utilities for processing documents saved in files. The file_util module has two main entry points: process_file and process_directory . process_file takes as parameters the processor and the input and output file names. process_directory is slightly more complex and it will be used in this example. In this example we will use the input directory used by all other examples and we will output the result to a new directory output2 at the same level with input . To keep the focus on the directory function we will keep things simple and use a filter processor that filters empty tags. from bs_processors.predicate import is_empty_p from bs_processors import filter_factory filter_empty = filter_factory ( is_empty_p ) In order to do our processing we'll use the following code: import util from bs_processors.utils.file_util import process_directory def main (): input_dir = util . relative_to_absolute_path_name ( __file__ , \"input\" ) output_dir = util . relative_to_absolute_path_name ( __file__ , \"output2\" ) process_directory ( filter_empty , 'html.parser' , input_dir , output_dir , \"*.html\" ) This will run all files that match *.html through the filter_empty processor and put the result in the output2 directory. process_directory will recreate the structure of the input directory in the output directory ( subdirectories from input will become subdirectories in output).","title":"How to use file and directory utilities"},{"location":"examples/use_process_directory/#how-to-use-file-and-directory-utilities","text":"","title":"How to use file and directory utilities"},{"location":"examples/use_process_directory/#overview","text":"In this example we will use the process_directory utility function to process a directory. In order to simplify the application of filters bs-processor contains utilities for processing documents saved in files. The file_util module has two main entry points: process_file and process_directory . process_file takes as parameters the processor and the input and output file names. process_directory is slightly more complex and it will be used in this example. In this example we will use the input directory used by all other examples and we will output the result to a new directory output2 at the same level with input . To keep the focus on the directory function we will keep things simple and use a filter processor that filters empty tags. from bs_processors.predicate import is_empty_p from bs_processors import filter_factory filter_empty = filter_factory ( is_empty_p ) In order to do our processing we'll use the following code: import util from bs_processors.utils.file_util import process_directory def main (): input_dir = util . relative_to_absolute_path_name ( __file__ , \"input\" ) output_dir = util . relative_to_absolute_path_name ( __file__ , \"output2\" ) process_directory ( filter_empty , 'html.parser' , input_dir , output_dir , \"*.html\" ) This will run all files that match *.html through the filter_empty processor and put the result in the output2 directory. process_directory will recreate the structure of the input directory in the output directory ( subdirectories from input will become subdirectories in output).","title":"Overview"}]}