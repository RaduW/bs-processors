{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About This is the documentation for bs-processors, a library for processing xml/html files parsed with BeautifulSoup API The api is still 'a work in progress' and can be found at: Api documentation","title":"About"},{"location":"#about","text":"This is the documentation for bs-processors, a library for processing xml/html files parsed with BeautifulSoup","title":"About"},{"location":"#api","text":"The api is still 'a work in progress' and can be found at: Api documentation","title":"API"},{"location":"how_to/","text":"Working with bs-processors Overview ... write overview The processors TODO The predicates TODO Writing your own predicates TODO Writing your own processors TODO","title":"Working with bs-processors"},{"location":"how_to/#working-with-bs-processors","text":"","title":"Working with bs-processors"},{"location":"how_to/#overview","text":"... write overview","title":"Overview"},{"location":"how_to/#the-processors","text":"TODO","title":"The processors"},{"location":"how_to/#the-predicates","text":"TODO","title":"The predicates"},{"location":"how_to/#writing-your-own-predicates","text":"TODO","title":"Writing your own predicates"},{"location":"how_to/#writing-your-own-processors","text":"TODO","title":"Writing your own processors"},{"location":"examples/","text":"About All examples listed below are available in the project's examples directory. The examples can be run as they are in a virtual environment that has BeautifulSoup and bs-processors installed. The examples documentation is directly extracted from the examples code.","title":"About"},{"location":"examples/#about","text":"All examples listed below are available in the project's examples directory. The examples can be run as they are in a virtual environment that has BeautifulSoup and bs-processors installed. The examples documentation is directly extracted from the examples code.","title":"About"},{"location":"examples/unwrap_tags/","text":"How to unwrap unwanted tags Overview In this example we will use the flatten_factory processor to unwrap unwanted tags. This covers the case when we have a source file that has deeply nested structures that we would like to flatten. This type of problem can be seen when we want to clean documents that were exported as html from various text editors. In our example the useful information is buried deep inside nested <div> that have various classes. To make matters worse some information is also buried inside <font> elements. We would like to remove all superfluous <div> elements and all <font> elements while preserving the content inside them. Let's say we have the following file that we want to clean up: Input <!DOCTYPE html> < html > < body > < div > < div class = \"useless-1 bold\" > First line < font >< font > inside double font </ font ></ font > outside font. < div class = \"useless-2\" > < p > Second line </ p > </ div > </ div > < div > < p > Third line </ p > </ div > </ div > < div > Forth line < font > inside font </ font > < span > end. </ span > </ div > </ body > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a predicate that checks if an element is a <font> or if it is a ` with a marker class that designates it as not necessary. Luckily we can construct this predicate from already available building blocks. To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p , or_pf , has_class_pf should_uwrap_p = or_pf ( has_name_pf ( 'font' ), and_pf ( has_name_pf ( 'div' ), has_class_pf ([ 'useless-1' , 'useless-2' ]) ) ) After constructing the predicate all that remains is to use it to create our processor from bs_processors import unwrap_factory remove_unnecessary_wrappers = unwrap_factory ( should_uwrap_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/deeply_nested.html\" ) result = remove_unnecessary_wrappers ([ doc ]) util . save_relative_result ( result , __file__ , \"output/deeply_nested_result.html\" ) The result is: <!DOCTYPE html> < html > < body > < div > First line inside double font outside font. < p > Second line </ p > < div > < p > Third line </ p > </ div > </ div > < div > Forth line inside font < span > end. </ span > </ div > </ body > </ html >","title":"How to unwrap unwanted tags"},{"location":"examples/unwrap_tags/#how-to-unwrap-unwanted-tags","text":"","title":"How to unwrap unwanted tags"},{"location":"examples/unwrap_tags/#overview","text":"In this example we will use the flatten_factory processor to unwrap unwanted tags. This covers the case when we have a source file that has deeply nested structures that we would like to flatten. This type of problem can be seen when we want to clean documents that were exported as html from various text editors. In our example the useful information is buried deep inside nested <div> that have various classes. To make matters worse some information is also buried inside <font> elements. We would like to remove all superfluous <div> elements and all <font> elements while preserving the content inside them. Let's say we have the following file that we want to clean up:","title":"Overview"},{"location":"examples/unwrap_tags/#input","text":"<!DOCTYPE html> < html > < body > < div > < div class = \"useless-1 bold\" > First line < font >< font > inside double font </ font ></ font > outside font. < div class = \"useless-2\" > < p > Second line </ p > </ div > </ div > < div > < p > Third line </ p > </ div > </ div > < div > Forth line < font > inside font </ font > < span > end. </ span > </ div > </ body > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a predicate that checks if an element is a <font> or if it is a ` with a marker class that designates it as not necessary. Luckily we can construct this predicate from already available building blocks. To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p , or_pf , has_class_pf should_uwrap_p = or_pf ( has_name_pf ( 'font' ), and_pf ( has_name_pf ( 'div' ), has_class_pf ([ 'useless-1' , 'useless-2' ]) ) ) After constructing the predicate all that remains is to use it to create our processor from bs_processors import unwrap_factory remove_unnecessary_wrappers = unwrap_factory ( should_uwrap_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/deeply_nested.html\" ) result = remove_unnecessary_wrappers ([ doc ]) util . save_relative_result ( result , __file__ , \"output/deeply_nested_result.html\" )","title":"Input"},{"location":"examples/unwrap_tags/#the-result-is","text":"<!DOCTYPE html> < html > < body > < div > First line inside double font outside font. < p > Second line </ p > < div > < p > Third line </ p > </ div > </ div > < div > Forth line inside font < span > end. </ span > </ div > </ body > </ html >","title":"The result is:"},{"location":"examples/use_filter_proc/","text":"How to use the filter processor Overview In this example we will use the filter processor to remove unwanted tags from a sample file Let's say we have the following file that we want to clean up: Input <!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < font > </ font > < span > end. </ span ></ div > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a filter that checks if an element is a <font> element and if it is empty. Luckily we can construct this predicate from already available building blocks. The has_name_pf predicate factory can be used to check if the passed element is font and the is_empty_p can be used to check if the element is empty (contains at most white spaces). To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p is_empty_font_p = and_pf ( has_name_pf ( 'font' ), is_empty_p ) After constructing the predicate all that remains is to use it to create our filter from bs_processors import filter_factory filter_empty_font_proc = filter_factory ( is_empty_font_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/simple_filter.html\" ) result = filter_empty_font_proc ([ doc ]) util . save_relative_result ( result , __file__ , \"output/simple_filter_result.html\" ) The result is: <!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < span > end. </ span ></ div > </ html >","title":"How to use the filter processor"},{"location":"examples/use_filter_proc/#how-to-use-the-filter-processor","text":"","title":"How to use the filter processor"},{"location":"examples/use_filter_proc/#overview","text":"In this example we will use the filter processor to remove unwanted tags from a sample file Let's say we have the following file that we want to clean up:","title":"Overview"},{"location":"examples/use_filter_proc/#input","text":"<!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < font > </ font > < span > end. </ span ></ div > </ html > We noticed that the file has some empty <font> tags that we want to remove if they do not contain any text. For that we can use the filter_factory processor. In the processor we need to pass a filter that checks if an element is a <font> element and if it is empty. Luckily we can construct this predicate from already available building blocks. The has_name_pf predicate factory can be used to check if the passed element is font and the is_empty_p can be used to check if the element is empty (contains at most white spaces). To construct our predicate we have the following code: from bs_processors import and_pf , has_name_pf , is_empty_p is_empty_font_p = and_pf ( has_name_pf ( 'font' ), is_empty_p ) After constructing the predicate all that remains is to use it to create our filter from bs_processors import filter_factory filter_empty_font_proc = filter_factory ( is_empty_font_p ) Now we are ready to pass it our loaded soup and we are done import util def main (): doc = util . load_relative_html_file ( __file__ , \"input/simple_filter.html\" ) result = filter_empty_font_proc ([ doc ]) util . save_relative_result ( result , __file__ , \"output/simple_filter_result.html\" )","title":"Input"},{"location":"examples/use_filter_proc/#the-result-is","text":"<!DOCTYPE html> < html > < div > First line < font id = \"not-empty\" > not empty </ font > </ div > < div > Second line < span > end. </ span ></ div > </ html >","title":"The result is:"}]}