<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>bs_processors.modify API documentation</title>
<meta name="description" content="Generic modification factories …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bs_processors.modify</code></h1>
</header>
<section id="section-intro">
<p>Generic modification factories.</p>
<p>This module contains factories that can be used to easily construct modification functions that can be
used as arguments to the local_modify function</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Generic modification factories.

This module contains factories that can be used to easily construct modification functions that can be
used as arguments to the local_modify function

&#34;&#34;&#34;
from typing import Any, Callable

from bs_processors import is_tag


def modify_if_f(modifier: Callable[[Any], None], predicate: Callable[[Any], bool]) -&gt; Callable[[Any], None]:
    &#34;&#34;&#34;
    Adaptor for a local modifier, it will be called only if the predicate returns True

    This modifier permits writing simple modifiers that apply their modification logic to all elements
    that they receive and delegate the selection logic to the predicate

    If, for example, we need a modifier that sets a certain class to all elements of type `p` we can create
    a modifier that sets the class to all elements that it receives and then use this function togehter with
    the `has_name_pf(&#39;p&#39;) to obtain the same result.

    :param modifier: a modifier that applies the modification to all elements it is called with
    :param predicate: a predicate that selects the elements to be modified
    :return: a modifier that applies the modification to the elements selected by the predicate

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; from bs_processors.predicate import has_name_pf
    &gt;&gt;&gt; from bs_processors.generic_processors import local_modify_factory
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;span&gt;s1&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;s2&lt;/span&gt;&lt;div&gt;&lt;span&gt;s3&lt;/span&gt;&lt;/div&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; s = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; is_span = has_name_pf(&#39;span&#39;)
    &gt;&gt;&gt; def modifier(elm):
    ...     clss = elm.get(&#39;class&#39;)
    ...     if clss is not None:
    ...         clss.append(&#34;my_class&#34;)
    ...     else:
    ...         elm[&#39;class&#39;] = &#39;my_class&#39;
    &gt;&gt;&gt; modif_span = modify_if_f( modifier, is_span)
    &gt;&gt;&gt; processor = local_modify_factory(modif_span)
    &gt;&gt;&gt; result = processor([s])
    &gt;&gt;&gt; result[0]
    &lt;html&gt;&lt;span class=&#34;my_class&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;c1 my_class&#34;&gt;s2&lt;/span&gt;&lt;div&gt;&lt;span \
class=&#34;my_class&#34;&gt;s3&lt;/span&gt;&lt;/div&gt;&lt;/html&gt;
    &#34;&#34;&#34;

    def inner(element):
        if predicate(element):
            modifier(element)


    return inner


def toggle_class(class_name_gen):
    &#34;&#34;&#34;
    Toggles a class on a HTML element

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

    * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;p  class=&#34;a1&#34;/&gt;&lt;p&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = toggle_class(&#39;bubu&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;bubu&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 bubu&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.p)
    &gt;&gt;&gt; x.p
    &lt;p class=&#34;a1 bubu&#34;&gt;&lt;/p&gt;
    &gt;&gt;&gt; tc(x.p)
    &gt;&gt;&gt; x.p
    &lt;p class=&#34;a1&#34;&gt;&lt;/p&gt;
    &gt;&gt;&gt; class_name_gen = lambda x: x.name
    &gt;&gt;&gt; tc = toggle_class(class_name_gen)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;div&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 span&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;

    &#34;&#34;&#34;
    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is None:
            elm[&#39;class&#39;] = [class_name]
        else:
            if class_name in clss:
                elm[&#39;class&#39;]= [cls for cls in clss if cls != class_name]
            else:
                clss.append(class_name)

    return inner

def remove_class(class_name_gen):
    &#34;&#34;&#34;
    Removes a class on a HTML element

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

    * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = remove_class(&#39;s1&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &#34;&#34;&#34;
    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is not None:
            elm[&#39;class&#39;]= [cls for cls in clss if cls != class_name]

    return inner

def set_class(class_name_gen):
    &#34;&#34;&#34;
    Sets a class (does not duplicate the class if it already exists).

    Unlike add_class it will not add a class multiple times (if the class is already set it will not add it again)

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

     * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: local modification function

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = set_class(&#39;s1&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;s1&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &#34;&#34;&#34;
    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is None:
            elm[&#39;class&#39;] = [class_name]
        else:
            if class_name not in clss:
                clss.append(class_name)

    return inner

def add_class(class_name_gen):
    &#34;&#34;&#34;
    Toggles a class on a HTML element

    Unlike set_class it will add a class multiple times (if the class is already set it will add it again)

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

    * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = add_class(&#39;s1&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;s1&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 s1&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 s1 s1&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &#34;&#34;&#34;

    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is None:
            elm[&#39;class&#39;] = [class_name]
        else:
            clss.append(class_name)

    return inner


def change_tag_name(tag_name_gen):
    &#34;&#34;&#34;
    Changes the tag name of a tag (e.g. change `div` to `p`)


    * **tag_name_gen**: something that can be converted into a class name
        * st4 the string is the new tag name
        * Callable[[Any], str] a function that receives an element and returns a string, the new tag name to be set
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;&gt;&lt;/span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = change_tag_name(&#39;p&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x
    &lt;html&gt;&lt;p&gt;&lt;/p&gt;&lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;&lt;/html&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x
    &lt;html&gt;&lt;p&gt;&lt;/p&gt;&lt;p class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/p&gt;&lt;/html&gt;
    &#34;&#34;&#34;
    tag_name_gen = to_string_gen(tag_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        elm.name = tag_name_gen(elm)

    return inner


def to_string_gen(gen) -&gt; Callable[[Any], str]:
    &#34;&#34;&#34;
    Accepts a string or a function that returns a string and returns a function that returns a string

    :param gen: either the string to be returned or a generator that accepts an element and returns a string
    :return:  a string generator that accepts an element

    &gt;&gt;&gt; s_gen = to_string_gen(&#34;some_constant&#34;)
    &gt;&gt;&gt; s_gen(1)
    &#39;some_constant&#39;
    &gt;&gt;&gt; s_gen(&#34;hello&#34;)
    &#39;some_constant&#39;
    &gt;&gt;&gt; echo_gen = to_string_gen( lambda x: str(x))
    &gt;&gt;&gt; echo_gen(1)
    &#39;1&#39;
    &gt;&gt;&gt; echo_gen(&#34;hello&#34;)
    &#39;hello&#39;
    &#34;&#34;&#34;
    if gen is None:
        return lambda x: &#34;&#34;
    if isinstance(gen, str):
        return lambda x: gen
    else:
        return gen</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bs_processors.modify.add_class"><code class="name flex">
<span>def <span class="ident">add_class</span></span>(<span>class_name_gen)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles a class on a HTML element</p>
<p>Unlike set_class it will add a class multiple times (if the class is already set it will add it again)</p>
<p><strong>Important</strong>: this works with the assumption that the element is processed with 'html.parser' or something
similar, that is the 'class' attribute is a list of classes. If processing with the 'html' parser the 'class'
attribute is treated as a simple string and toggle_class will not function correctly.</p>
<ul>
<li><strong>class_name_gen</strong>: something that can be converted into a class name<ul>
<li>st4 the string is the class name</li>
<li>Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled</li>
</ul>
</li>
<li><strong>return</strong>: a local modification function ( a function that can be applied on an element)</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup
&gt;&gt;&gt; doc = '&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&quot;1&quot; class=&quot;s1 s2&quot;/&gt;&lt;span&gt;&lt;/html&gt;'
&gt;&gt;&gt; x = BeautifulSoup(doc, 'html.parser')
&gt;&gt;&gt; tc = add_class('s1')
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x.div
&lt;div class=&quot;s1&quot;&gt;&lt;/div&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s1 s2 s1&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s1 s2 s1 s1&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_class(class_name_gen):
    &#34;&#34;&#34;
    Toggles a class on a HTML element

    Unlike set_class it will add a class multiple times (if the class is already set it will add it again)

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

    * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = add_class(&#39;s1&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;s1&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 s1&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 s1 s1&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &#34;&#34;&#34;

    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is None:
            elm[&#39;class&#39;] = [class_name]
        else:
            clss.append(class_name)

    return inner</code></pre>
</details>
</dd>
<dt id="bs_processors.modify.change_tag_name"><code class="name flex">
<span>def <span class="ident">change_tag_name</span></span>(<span>tag_name_gen)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the tag name of a tag (e.g. change <code>div</code> to <code>p</code>)</p>
<ul>
<li><strong>tag_name_gen</strong>: something that can be converted into a class name<ul>
<li>st4 the string is the new tag name</li>
<li>Callable[[Any], str] a function that receives an element and returns a string, the new tag name to be set</li>
</ul>
</li>
<li><strong>return</strong>: a local modification function ( a function that can be applied on an element)</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup
&gt;&gt;&gt; doc = '&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&quot;1&quot; class=&quot;s1 s2&quot;&gt;&lt;/span&gt;&lt;/html&gt;'
&gt;&gt;&gt; x = BeautifulSoup(doc, 'html.parser')
&gt;&gt;&gt; tc = change_tag_name('p')
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x
&lt;html&gt;&lt;p&gt;&lt;/p&gt;&lt;span class=&quot;s1 s2&quot; id=&quot;1&quot;&gt;&lt;/span&gt;&lt;/html&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x
&lt;html&gt;&lt;p&gt;&lt;/p&gt;&lt;p class=&quot;s1 s2&quot; id=&quot;1&quot;&gt;&lt;/p&gt;&lt;/html&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_tag_name(tag_name_gen):
    &#34;&#34;&#34;
    Changes the tag name of a tag (e.g. change `div` to `p`)


    * **tag_name_gen**: something that can be converted into a class name
        * st4 the string is the new tag name
        * Callable[[Any], str] a function that receives an element and returns a string, the new tag name to be set
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;&gt;&lt;/span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = change_tag_name(&#39;p&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x
    &lt;html&gt;&lt;p&gt;&lt;/p&gt;&lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;&lt;/html&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x
    &lt;html&gt;&lt;p&gt;&lt;/p&gt;&lt;p class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/p&gt;&lt;/html&gt;
    &#34;&#34;&#34;
    tag_name_gen = to_string_gen(tag_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        elm.name = tag_name_gen(elm)

    return inner</code></pre>
</details>
</dd>
<dt id="bs_processors.modify.modify_if_f"><code class="name flex">
<span>def <span class="ident">modify_if_f</span></span>(<span>modifier: Callable[[Any], NoneType], predicate: Callable[[Any], bool]) -> Callable[[Any], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Adaptor for a local modifier, it will be called only if the predicate returns True</p>
<p>This modifier permits writing simple modifiers that apply their modification logic to all elements
that they receive and delegate the selection logic to the predicate</p>
<p>If, for example, we need a modifier that sets a certain class to all elements of type <code>p</code> we can create
a modifier that sets the class to all elements that it receives and then use this function togehter with
the `has_name_pf('p') to obtain the same result.</p>
<p>:param modifier: a modifier that applies the modification to all elements it is called with
:param predicate: a predicate that selects the elements to be modified
:return: a modifier that applies the modification to the elements selected by the predicate</p>
<pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup
&gt;&gt;&gt; from bs_processors.predicate import has_name_pf
&gt;&gt;&gt; from bs_processors.generic_processors import local_modify_factory
&gt;&gt;&gt; doc = '&lt;html&gt;&lt;span&gt;s1&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;s2&lt;/span&gt;&lt;div&gt;&lt;span&gt;s3&lt;/span&gt;&lt;/div&gt;&lt;/html&gt;'
&gt;&gt;&gt; s = BeautifulSoup(doc, 'html.parser')
&gt;&gt;&gt; is_span = has_name_pf('span')
&gt;&gt;&gt; def modifier(elm):
...     clss = elm.get('class')
...     if clss is not None:
...         clss.append(&quot;my_class&quot;)
...     else:
...         elm['class'] = 'my_class'
&gt;&gt;&gt; modif_span = modify_if_f( modifier, is_span)
&gt;&gt;&gt; processor = local_modify_factory(modif_span)
&gt;&gt;&gt; result = processor([s])
&gt;&gt;&gt; result[0]
&lt;html&gt;&lt;span class=&quot;my_class&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;c1 my_class&quot;&gt;s2&lt;/span&gt;&lt;div&gt;&lt;span class=&quot;my_class&quot;&gt;s3&lt;/span&gt;&lt;/div&gt;&lt;/html&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify_if_f(modifier: Callable[[Any], None], predicate: Callable[[Any], bool]) -&gt; Callable[[Any], None]:
    &#34;&#34;&#34;
    Adaptor for a local modifier, it will be called only if the predicate returns True

    This modifier permits writing simple modifiers that apply their modification logic to all elements
    that they receive and delegate the selection logic to the predicate

    If, for example, we need a modifier that sets a certain class to all elements of type `p` we can create
    a modifier that sets the class to all elements that it receives and then use this function togehter with
    the `has_name_pf(&#39;p&#39;) to obtain the same result.

    :param modifier: a modifier that applies the modification to all elements it is called with
    :param predicate: a predicate that selects the elements to be modified
    :return: a modifier that applies the modification to the elements selected by the predicate

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; from bs_processors.predicate import has_name_pf
    &gt;&gt;&gt; from bs_processors.generic_processors import local_modify_factory
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;span&gt;s1&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;s2&lt;/span&gt;&lt;div&gt;&lt;span&gt;s3&lt;/span&gt;&lt;/div&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; s = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; is_span = has_name_pf(&#39;span&#39;)
    &gt;&gt;&gt; def modifier(elm):
    ...     clss = elm.get(&#39;class&#39;)
    ...     if clss is not None:
    ...         clss.append(&#34;my_class&#34;)
    ...     else:
    ...         elm[&#39;class&#39;] = &#39;my_class&#39;
    &gt;&gt;&gt; modif_span = modify_if_f( modifier, is_span)
    &gt;&gt;&gt; processor = local_modify_factory(modif_span)
    &gt;&gt;&gt; result = processor([s])
    &gt;&gt;&gt; result[0]
    &lt;html&gt;&lt;span class=&#34;my_class&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;c1 my_class&#34;&gt;s2&lt;/span&gt;&lt;div&gt;&lt;span \
class=&#34;my_class&#34;&gt;s3&lt;/span&gt;&lt;/div&gt;&lt;/html&gt;
    &#34;&#34;&#34;

    def inner(element):
        if predicate(element):
            modifier(element)


    return inner</code></pre>
</details>
</dd>
<dt id="bs_processors.modify.remove_class"><code class="name flex">
<span>def <span class="ident">remove_class</span></span>(<span>class_name_gen)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a class on a HTML element</p>
<p><strong>Important</strong>: this works with the assumption that the element is processed with 'html.parser' or something
similar, that is the 'class' attribute is a list of classes. If processing with the 'html' parser the 'class'
attribute is treated as a simple string and toggle_class will not function correctly.</p>
<ul>
<li><strong>class_name_gen</strong>: something that can be converted into a class name<ul>
<li>st4 the string is the class name</li>
<li>Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled</li>
</ul>
</li>
<li><strong>return</strong>: a local modification function ( a function that can be applied on an element)</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup
&gt;&gt;&gt; doc = '&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&quot;1&quot; class=&quot;s1 s2&quot;/&gt;&lt;span&gt;&lt;/html&gt;'
&gt;&gt;&gt; x = BeautifulSoup(doc, 'html.parser')
&gt;&gt;&gt; tc = remove_class('s1')
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x.div
&lt;div&gt;&lt;/div&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s2&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_class(class_name_gen):
    &#34;&#34;&#34;
    Removes a class on a HTML element

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

    * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = remove_class(&#39;s1&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &#34;&#34;&#34;
    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is not None:
            elm[&#39;class&#39;]= [cls for cls in clss if cls != class_name]

    return inner</code></pre>
</details>
</dd>
<dt id="bs_processors.modify.set_class"><code class="name flex">
<span>def <span class="ident">set_class</span></span>(<span>class_name_gen)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a class (does not duplicate the class if it already exists).</p>
<p>Unlike add_class it will not add a class multiple times (if the class is already set it will not add it again)</p>
<p><strong>Important</strong>: this works with the assumption that the element is processed with 'html.parser' or something
similar, that is the 'class' attribute is a list of classes. If processing with the 'html' parser the 'class'
attribute is treated as a simple string and toggle_class will not function correctly.</p>
<ul>
<li><strong>class_name_gen</strong>: something that can be converted into a class name<ul>
<li>st4 the string is the class name</li>
<li>Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled</li>
</ul>
</li>
<li><strong>return</strong>: local modification function</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup
&gt;&gt;&gt; doc = '&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&quot;1&quot; class=&quot;s1 s2&quot;/&gt;&lt;span&gt;&lt;/html&gt;'
&gt;&gt;&gt; x = BeautifulSoup(doc, 'html.parser')
&gt;&gt;&gt; tc = set_class('s1')
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x.div
&lt;div class=&quot;s1&quot;&gt;&lt;/div&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s1 s2&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_class(class_name_gen):
    &#34;&#34;&#34;
    Sets a class (does not duplicate the class if it already exists).

    Unlike add_class it will not add a class multiple times (if the class is already set it will not add it again)

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

     * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: local modification function

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = set_class(&#39;s1&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;s1&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &#34;&#34;&#34;
    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is None:
            elm[&#39;class&#39;] = [class_name]
        else:
            if class_name not in clss:
                clss.append(class_name)

    return inner</code></pre>
</details>
</dd>
<dt id="bs_processors.modify.to_string_gen"><code class="name flex">
<span>def <span class="ident">to_string_gen</span></span>(<span>gen) -> Callable[[Any], str]</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts a string or a function that returns a string and returns a function that returns a string</p>
<p>:param gen: either the string to be returned or a generator that accepts an element and returns a string
:return:
a string generator that accepts an element</p>
<pre><code class="python">&gt;&gt;&gt; s_gen = to_string_gen(&quot;some_constant&quot;)
&gt;&gt;&gt; s_gen(1)
'some_constant'
&gt;&gt;&gt; s_gen(&quot;hello&quot;)
'some_constant'
&gt;&gt;&gt; echo_gen = to_string_gen( lambda x: str(x))
&gt;&gt;&gt; echo_gen(1)
'1'
&gt;&gt;&gt; echo_gen(&quot;hello&quot;)
'hello'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string_gen(gen) -&gt; Callable[[Any], str]:
    &#34;&#34;&#34;
    Accepts a string or a function that returns a string and returns a function that returns a string

    :param gen: either the string to be returned or a generator that accepts an element and returns a string
    :return:  a string generator that accepts an element

    &gt;&gt;&gt; s_gen = to_string_gen(&#34;some_constant&#34;)
    &gt;&gt;&gt; s_gen(1)
    &#39;some_constant&#39;
    &gt;&gt;&gt; s_gen(&#34;hello&#34;)
    &#39;some_constant&#39;
    &gt;&gt;&gt; echo_gen = to_string_gen( lambda x: str(x))
    &gt;&gt;&gt; echo_gen(1)
    &#39;1&#39;
    &gt;&gt;&gt; echo_gen(&#34;hello&#34;)
    &#39;hello&#39;
    &#34;&#34;&#34;
    if gen is None:
        return lambda x: &#34;&#34;
    if isinstance(gen, str):
        return lambda x: gen
    else:
        return gen</code></pre>
</details>
</dd>
<dt id="bs_processors.modify.toggle_class"><code class="name flex">
<span>def <span class="ident">toggle_class</span></span>(<span>class_name_gen)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles a class on a HTML element</p>
<p><strong>Important</strong>: this works with the assumption that the element is processed with 'html.parser' or something
similar, that is the 'class' attribute is a list of classes. If processing with the 'html' parser the 'class'
attribute is treated as a simple string and toggle_class will not function correctly.</p>
<ul>
<li><strong>class_name_gen</strong>: something that can be converted into a class name<ul>
<li>st4 the string is the class name</li>
<li>Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled</li>
</ul>
</li>
<li><strong>return</strong>: a local modification function ( a function that can be applied on an element)</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup
&gt;&gt;&gt; doc = '&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&quot;1&quot; class=&quot;s1 s2&quot;/&gt;&lt;span&gt;&lt;p  class=&quot;a1&quot;/&gt;&lt;p&gt;&lt;/html&gt;'
&gt;&gt;&gt; x = BeautifulSoup(doc, 'html.parser')
&gt;&gt;&gt; tc = toggle_class('bubu')
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x.div
&lt;div class=&quot;bubu&quot;&gt;&lt;/div&gt;
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x.div
&lt;div class=&quot;&quot;&gt;&lt;/div&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s1 s2 bubu&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s1 s2&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
&gt;&gt;&gt; tc(x.p)
&gt;&gt;&gt; x.p
&lt;p class=&quot;a1 bubu&quot;&gt;&lt;/p&gt;
&gt;&gt;&gt; tc(x.p)
&gt;&gt;&gt; x.p
&lt;p class=&quot;a1&quot;&gt;&lt;/p&gt;
&gt;&gt;&gt; class_name_gen = lambda x: x.name
&gt;&gt;&gt; tc = toggle_class(class_name_gen)
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x.div
&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;
&gt;&gt;&gt; tc(x.div)
&gt;&gt;&gt; x.div
&lt;div class=&quot;&quot;&gt;&lt;/div&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s1 s2 span&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
&gt;&gt;&gt; tc(x.span)
&gt;&gt;&gt; x.span
&lt;span class=&quot;s1 s2&quot; id=&quot;1&quot;&gt;&lt;/span&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_class(class_name_gen):
    &#34;&#34;&#34;
    Toggles a class on a HTML element

    **Important**: this works with the assumption that the element is processed with &#39;html.parser&#39; or something
    similar, that is the &#39;class&#39; attribute is a list of classes. If processing with the &#39;html&#39; parser the &#39;class&#39;
    attribute is treated as a simple string and toggle_class will not function correctly.

    * **class_name_gen**: something that can be converted into a class name
        * st4 the string is the class name
        * Callable[[Any], str] a function that receives an element and returns a string, the class name to be toggled
    * **return**: a local modification function ( a function that can be applied on an element)

    &gt;&gt;&gt; from bs4 import BeautifulSoup
    &gt;&gt;&gt; doc = &#39;&lt;html&gt;&lt;div&gt;&lt;/div&gt;&lt;span id=&#34;1&#34; class=&#34;s1 s2&#34;/&gt;&lt;span&gt;&lt;p  class=&#34;a1&#34;/&gt;&lt;p&gt;&lt;/html&gt;&#39;
    &gt;&gt;&gt; x = BeautifulSoup(doc, &#39;html.parser&#39;)
    &gt;&gt;&gt; tc = toggle_class(&#39;bubu&#39;)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;bubu&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 bubu&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.p)
    &gt;&gt;&gt; x.p
    &lt;p class=&#34;a1 bubu&#34;&gt;&lt;/p&gt;
    &gt;&gt;&gt; tc(x.p)
    &gt;&gt;&gt; x.p
    &lt;p class=&#34;a1&#34;&gt;&lt;/p&gt;
    &gt;&gt;&gt; class_name_gen = lambda x: x.name
    &gt;&gt;&gt; tc = toggle_class(class_name_gen)
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;div&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.div)
    &gt;&gt;&gt; x.div
    &lt;div class=&#34;&#34;&gt;&lt;/div&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2 span&#34; id=&#34;1&#34;&gt;&lt;/span&gt;
    &gt;&gt;&gt; tc(x.span)
    &gt;&gt;&gt; x.span
    &lt;span class=&#34;s1 s2&#34; id=&#34;1&#34;&gt;&lt;/span&gt;

    &#34;&#34;&#34;
    class_name_gen = to_string_gen(class_name_gen)
    def inner(elm):
        if not is_tag(elm):
            return

        clss = elm.get(&#34;class&#34;)
        class_name = class_name_gen(elm)
        if clss is None:
            elm[&#39;class&#39;] = [class_name]
        else:
            if class_name in clss:
                elm[&#39;class&#39;]= [cls for cls in clss if cls != class_name]
            else:
                clss.append(class_name)

    return inner</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bs_processors" href="index.html">bs_processors</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="bs_processors.modify.add_class" href="#bs_processors.modify.add_class">add_class</a></code></li>
<li><code><a title="bs_processors.modify.change_tag_name" href="#bs_processors.modify.change_tag_name">change_tag_name</a></code></li>
<li><code><a title="bs_processors.modify.modify_if_f" href="#bs_processors.modify.modify_if_f">modify_if_f</a></code></li>
<li><code><a title="bs_processors.modify.remove_class" href="#bs_processors.modify.remove_class">remove_class</a></code></li>
<li><code><a title="bs_processors.modify.set_class" href="#bs_processors.modify.set_class">set_class</a></code></li>
<li><code><a title="bs_processors.modify.to_string_gen" href="#bs_processors.modify.to_string_gen">to_string_gen</a></code></li>
<li><code><a title="bs_processors.modify.toggle_class" href="#bs_processors.modify.toggle_class">toggle_class</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>